open! Common
open V1

module Update_source : sig
  type t =
    [ `Market_data
    | `Trade
    | `External_trade
    ]
  [@@deriving equal, compare, enumerate]

  include Json.S with type t := t
end

module Entry : sig
  type t =
    { (** Market symbol (exchange-specific enum or string). *)
      symbol : Symbol.Enum_or_string.t;
      (** Total profit and loss for this entry (realized + unrealized). *)
      pnl : float;
      (** Net position size (positive = long, negative = short). *)
      position : float;
      (** Current spot/market price for the symbol. *)
      spot : float;
      (** PnL calculated against the current spot price (unrealized). *)
      pnl_spot : float;
      (** Notional value of the position (position * running price). *)
      notional : float;
      (** Average price of executed buy fills for this symbol. *)
      avg_buy_price : float;
      (** Average price of executed sell fills for this symbol. *)
      avg_sell_price : float;
      (** Overall average execution price combining buys and sells. *)
      avg_price : float;
      (** Time when this entry was last updated. *)
      update_time : Timestamp.t;
      (** Source of the most recent update (market data, trade, external). *)
      update_source : Update_source.t;
      (** Cumulative quantity bought. *)
      total_buy_qty : float;
      (** Cumulative quantity sold. *)
      total_sell_qty : float;
      (** Best known price for the entry (wrapped in Price.Option). *)
      price : Price.Option.t;
      (** Side associated with the latest price/quote (wrapped in Side.Option). *)
      side : Side.Option.t;
      (** Quantity associated with the latest price/quote (wrapped in Price.Option). *)
      qty : Price.Option.t;
      (** Aggregated package/filled price when trades are executed as a package. *)
      package_price : Price.Option.t;
      (** Cumulative notional bought. *)
      buy_notional : float;
      (** Cumulative notional sold. *)
      sell_notional : float;
      (** Total original quantity for outstanding orders (submitted). *)
      total_original : float;
      (** Total quantity executed so far. *)
      total_executed : float;
      (** Total remaining quantity for outstanding orders. *)
      total_remaining : float;
      (** Cost basis used for accounting / P&L calculations. *)
      cost_basis : float;
      (** Running (latest) reference price used to compute notional and P&L. *)
      running_price : float;
      (** Running aggregate executed quantity (used with running_price). *)
      running_qty : float
    }
  [@@deriving sexp, compare, equal, fields, csv]

  val create :
    ?notional:float ->
    ?update_source:Update_source.t ->
    ?update_time:Timestamp.t ->
    symbol:Symbol.Enum_or_string.t ->
    unit ->
    t

  val on_trade :
    ?update_source:Update_source.t ->
    ?timestamp:Timestamp.t ->
    ?avg_trade_price:float ->
    t ->
    price:float ->
    side:Side.t ->
    qty:float ->
    t

  val update_spot : ?timestamp:Timestamp.t -> t -> float -> t

  val update_from_book : t -> Order_book.Book.t -> t

  val pipe :
    init:t ->
    ?num_values:int ->
    ?behavior:[ `Alternate | `Priority | `Random ] ->
    Order_book.Book.t Pipe.Reader.t ->
    Order_events.response Pipe.Reader.t ->
    t Pipe.Reader.t Deferred.t
  (* [pipe init ?num_values ?behavior book events] produces a pipe of entry updates starting with [init], pushing
      new entries on the pipe for [t.symbol] by either public order [book] updates (which
      affect unrealized pnl) or the private order [events] pipe which affect both realize and unrealized.

      At most [num_values] are emitted on the pipe, and the [behavior] determines how the pipe
      will select between the two sources. *)

  val from_mytrades :
    ?init:t Symbol.Enum_or_string.Map.t ->
    ?avg_trade_prices:float Symbol.Enum_or_string.Map.t ->
    Mytrades.response ->
    t Symbol.Enum_or_string.Map.t * t Pipe.Reader.t Symbol.Enum_or_string.Map.t
  (* [from_mytades ?init ?avg_trade_prices response]
     produces ledger entries from responses generated by the mytrades api.
     Given an optional [init] of initial entries for each symbol and
     optional [avg_trace_prices] that maps symbols to trade prices to
     estimate external trades using the average cost method.

     If any trade occurs that would end up in a short position of a
     particular symbol, the symbol map is then used to assume a prior
     buy using the price as given in the map. *)

  val from_mytrades_pipe :
    ?symbols:Symbol.Enum_or_string.t list ->
    ?init:t Symbol.Enum_or_string.Map.t ->
    ?timestamp:Timestamp.t ->
    ?how:Monad_sequence.how ->
    ?avg_trade_prices:float Symbol.Enum_or_string.Map.t ->
    ?nonce:Nonce.reader ->
    (module Cfg.S) ->
    Order_events.response Pipe.Reader.t ->
    t Pipe.Reader.t Symbol.Enum_or_string.Map.t Deferred.t
end

type t = Entry.t Symbol.Enum_or_string.Map.t [@@deriving sexp, compare, equal]

val update_from_books : t -> books:Order_book.Books.t -> t

val update_from_book' : t -> book:Order_book.Book.t -> t

val on_trade' :
  ?update_source:Update_source.t ->
  ?timestamp:Timestamp.t ->
  ?avg_trade_price:float ->
  t ->
  symbol:Symbol.Enum_or_string.t ->
  price:Price.t ->
  side:Side.t ->
  qty:float ->
  t

val on_order_events : t -> Order_events.Order_event.t list -> t

val on_order_event_response : t -> Order_events.response -> t

val update_spots :
  ?timestamp:Timestamp.t -> t -> float Symbol.Enum_or_string.Map.t -> t

val pipe :
  ?num_values:int ->
  ?behavior:[ `Alternate | `Priority | `Random ] ->
  ?how:Monad_sequence.how ->
  init:Entry.t Symbol.Map.t ->
  Order_book.Book.t Pipe.Reader.t Symbol.Map.t ->
  Order_events.response Pipe.Reader.t ->
  Entry.t Pipe.Reader.t Symbol.Map.t Deferred.t

val command : string * Command.t
