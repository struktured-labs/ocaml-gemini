open! Common
open V1

module Currency_map : Map.S with type Key.t := Currency.Enum_or_string.t

module Symbol_map : Map.S with type Key.t = Symbol.Enum_or_string.t

module Update_source : sig
  type t =
    [ `Market_data
    | `Trade
    | `External_trade
    ]
  [@@deriving equal, compare, enumerate]

  include Json.S with type t := t
end

module Entry : sig
  type t =
    { symbol : Symbol.Enum_or_string.t;
      pnl : float;
      position : float;
      spot : float;
      pnl_spot : float;
      notional : float;
      avg_buy_price : float;
      avg_sell_price : float;
      update_time : Timestamp.t;
      update_source : Update_source.t;
      total_buy_qty : float;
      total_sell_qty : float;
      price : Price.Option.t;
      side : Side.Option.t;
      qty : Price.Option.t;
      package_price : Price.Option.t;
      buy_notional : float;
      sell_notional : float
    }
  [@@deriving sexp, compare, equal, fields, csv]

  val create :
    ?notional:float ->
    ?update_source:Update_source.t ->
    ?update_time:Timestamp.t ->
    symbol:Symbol.Enum_or_string.t ->
    unit ->
    t

  val on_trade :
    ?update_source:Update_source.t ->
    ?timestamp:Timestamp.t ->
    ?avg_trade_price:float ->
    t ->
    price:float ->
    side:Side.t ->
    qty:float ->
    t

  val update_spot : ?timestamp:Timestamp.t -> t -> float -> t

  val update_from_book : t -> Order_book.Book.t -> t

  val pipe :
    init:t ->
    ?num_values:int ->
    ?behavior:[ `Alternate | `Priority | `Random ] ->
    Order_book.Book.t Pipe.Reader.t ->
    Order_events.response Pipe.Reader.t ->
    t Pipe.Reader.t Deferred.t
  (* [pipe init ?num_values ?behavior book events] produces a pipe of entry updates starting with [init], pushing
      new entries on the pipe for [t.symbol] by either public order [book] updates (which
      affect unrealized pnl) or the private order [events] pipe which affect both realize and unrealized.

      At most [num_values] are emitted on the pipe, and the [behavior] determines how the pipe 
      will select between the two sources. *)

  val from_mytrades :
    ?init:t Symbol_map.t ->
    ?avg_trade_prices:float Symbol_map.t ->
    Mytrades.response ->
    t Symbol_map.t * t Pipe.Reader.t Symbol_map.t
  (* [from_mytades ?init ?avg_trade_prices response]
     produces ledger entries from responses generated by the mytrades api.
     Given an optional [init] of initial entries for each symbol and
     optional [avg_trace_prices] that maps symbols to trade prices to
     estimate external trades using the average cost method.

     If any trade occurs that would end up in a short position of a
     particular symbol, the symbol map is then used to assume a prior
     buy using the price as given in the map. *)

  val from_mytrades_pipe :
    ?symbols:Symbol.Enum_or_string.t list ->
    ?init:t Symbol_map.t ->
    ?timestamp:Timestamp.t ->
    ?how:Monad_sequence.how ->
    ?avg_trade_prices:float Symbol_map.t ->
    ?nonce:Nonce.reader ->
    (module Cfg.S) ->
    Order_events.response Pipe.Reader.t ->
    t Pipe.Reader.t Symbol_map.t Deferred.t
end


module type S = sig
  type t = (Entry.t Symbol_map.t[@deriving sexp, equal, compare])

  val from_mytrades :
    ?avg_trade_prices:float Symbol_map.t ->
    Mytrades.response ->
    t * Entry.t Pipe.Reader.t

  val update_spots : ?timestamp:Timestamp.t -> t -> float Symbol_map.t -> t

  val command : string * Command.t
end

type t = Entry.t Symbol_map.t [@@deriving sexp, compare, equal]

val update_from_books : t -> books:Order_book.Books.t -> t

val update_from_book' : t -> book:Order_book.Book.t -> t

val on_trade' :
  ?update_source:Update_source.t ->
  ?timestamp:Timestamp.t ->
  ?avg_trade_price:float ->
  t ->
  symbol:Symbol.Enum_or_string.t ->
  price:Price.t ->
  side:Side.t ->
  qty:float ->
  t

val on_order_events : t -> Order_events.Order_event.t list -> t

val on_order_event_response : t -> Order_events.response -> t

val update_spots : ?timestamp:Timestamp.t -> t -> float Symbol_map.t -> t

val command : string * Command.t
